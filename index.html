<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App Segurança Motorista</title>
    <!-- Inclui Tailwind CSS para estilização rápida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Icones para o botão "Voltar" e "Download" -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">


    <style>
        /* Estilos base para o corpo da página */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Garante que ocupe a altura total da viewport */
            margin: 0;
            padding: 10px; /* Padding geral */
            box-sizing: border-box;
        }
        /* Container principal do aplicativo */
        .container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            width: 100%;
            max-width: 680px; /* Largura máxima um pouco maior para telas grandes */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px; /* Padding ajustado */
            gap: 15px; /* Espaçamento entre seções */
        }
        /* Estilos para o grupo de vídeos (câmeras) */
        .video-group {
            display: flex;
            flex-direction: column; /* Padrão: vídeos empilhados para mobile */
            width: 100%;
            gap: 12px; /* Espaçamento entre os vídeos */
        }
        /* Estilos para a pré-visualização de cada vídeo */
        .video-preview {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            border-radius: 10px;
            overflow: hidden;
        }
        /* Wrapper para manter o aspecto ratio do vídeo (16:9) */
        .video-wrapper {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio (9 / 16 * 100%) */
            background-color: #2c3e50; /* Cor escura para preencher enquanto vídeo não carrega */
            border-radius: 10px;
            overflow: hidden;
        }
        /* Estilos para o elemento de vídeo dentro do wrapper de aspecto ratio */
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 2px solid #ddd;
            display: block;
        }
        /* Responsividade para telas maiores (tablets e desktops) */
        @media (min-width: 600px) { /* Breakpoint ligeiramente menor para Tablets */
            .video-group {
                flex-direction: row; /* Vídeos lado a lado */
                justify-content: space-between; /* Espaço entre os vídeos */
            }
            .video-preview {
                width: 49%; /* Ajuste para ter um pequeno gap no meio */
            }
        }
        /* Controles (botões) */
        .controls {
            display: grid; /* Usando grid para melhor controle de layout */
            grid-template-columns: 1fr; /* Uma coluna por padrão para mobile */
            gap: 10px; /* Espaçamento entre os botões */
            width: 100%;
        }
        /* Responsividade para botões em telas maiores */
        @media (min-width: 400px) { /* A partir de uma largura de celular um pouco maior */
            .controls {
                grid-template-columns: 1fr 1fr; /* Duas colunas */
            }
            .button.span-full { /* Botão Pânico ocupa toda a linha */
                grid-column: 1 / -1;
            }
        }
        @media (min-width: 600px) { /* Para tablets e desktops */
            .controls {
                grid-template-columns: repeat(3, 1fr); /* Três colunas */
            }
        }

        /* Estilos gerais dos botões */
        .button {
            padding: 12px 15px; /* Padding ajustado para otimizar espaço */
            border-radius: 10px;
            font-size: 0.95em; /* Fonte ligeiramente menor para otimização de espaço */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
            white-space: nowrap; /* Evita que o texto quebre em várias linhas */
        }
        .button-primary {
            background-image: linear-gradient(to right, #4CAF50, #66BB6A);
            color: white;
            border: none;
        }
        .button-primary:hover {
            background-image: linear-gradient(to right, #66BB6A, #81C784);
            transform: translateY(-1px);
        }
        .button-danger {
            background-image: linear-gradient(to right, #f44336, #ef5350);
            color: white;
            border: none;
        }
        .button-danger:hover {
            background-image: linear-gradient(to right, #ef5350, #e57373);
            transform: translateY(-1px);
        }
        .button-secondary {
            background-color: #e0e0e0;
            color: #333;
            border: 1px solid #ccc;
        }
        .button-secondary:hover {
            background-color: #d0d0d0;
        }
        /* Caixa de mensagens */
        .message-box {
            background-color: #ffe0b2;
            color: #e65100;
            padding: 10px; /* Padding reduzido */
            border-radius: 8px;
            text-align: center;
            width: 100%;
            font-weight: 500;
            margin-top: 8px;
            display: none; /* Controlado por JS */
            font-size: 0.9em; /* Fonte menor */
            word-wrap: break-word; /* Garante que o texto longo se ajuste */
        }
        /* Overlay de gravação (cronômetro e indicador) */
        .recording-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            background-color: rgba(0, 0, 0, 0.65);
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.8em; /* Fonte menor para caber melhor */
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 10;
            display: none; /* Controlado por JS */
        }
        .recording-overlay.active {
            display: flex;
        }
        /* Ponto de gravação pulsante */
        .recording-dot {
            width: 8px;
            height: 8px;
            background-color: red;
            border-radius: 50%;
            animation: pulse 1s infinite alternate;
        }
        /* Animação de pulso */
        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }

        /* --- Estilos para as telas de Login e App --- */
        .login-screen, .app-screen, .saved-videos-screen, .video-player-screen {
            display: none; /* Controlado via JS */
            width: 100%;
            max-width: 500px;
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .login-screen h2, .saved-videos-screen h2, .video-player-screen h2 {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
        }

        /* ESTILOS PARA O BOTÃO SAIR NO CANTO SUPERIOR DIREITO */
        #topRightLogoutButton {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 100;
            padding: 8px 15px;
            background-color: #ef5350; /* Vermelho */
            color: white;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
        }
        #topRightLogoutButton:hover {
            background-color: #e53935;
            transform: translateY(-1px);
        }

        /* Estilo para o botão de login do Google (personalizado) */
        #googleSignInButton {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid #dadce0;
            background-color: white;
            font-size: 1.1em;
            font-weight: 500;
            color: #3c4043;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        #googleSignInButton:hover {
            background-color: #f7f7f7;
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        #googleSignInButton img {
            width: 20px;
            height: 20px;
        }

        /* Estilos do Modal de Salvamento */
        .save-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200; /* Acima de tudo */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .save-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .save-modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }
        .save-modal-overlay.active .save-modal-content {
            transform: translateY(0);
        }
        .save-modal-content h3 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #333;
        }
        .save-modal-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .save-modal-actions button {
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 1.0em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
            border: none;
        }
        .save-modal-actions .btn-save-phone { /* Renomeado para refletir a única opção */
            background-image: linear-gradient(to right, #1a73e8, #4285F4); /* Azul padrão */
            color: white;
        }
        .save-modal-actions .btn-save-phone:hover {
            background-image: linear-gradient(to right, #4285F4, #669df6);
            transform: translateY(-1px);
        }
        .save-modal-actions .btn-cancel-save {
            background-color: #f0f0f0;
            color: #555;
            border: 1px solid #ddd;
        }
        .save-modal-actions .btn-cancel-save:hover {
            background-color: #e0e0e0;
        }

        /* Estilos da Lista de Vídeos Salvos */
        .saved-videos-list {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Mais espaço entre os itens de vídeo */
            max-height: 450px; /* Limita a altura para rolagem */
            overflow-y: auto; /* Adiciona barra de rolagem */
            padding-right: 5px; /* Espaço para a barra de rolagem */
            padding-bottom: 10px; /* Espaço extra no final */
        }
        .saved-video-item {
            background-color: #f8f8f8;
            padding: 15px; /* Mais padding */
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08); /* Sombra mais visível */
            display: flex;
            flex-direction: column;
            align-items: center; /* Centraliza o conteúdo (vídeo e texto) */
            gap: 10px;
            width: 100%;
            cursor: pointer; /* Indica que é clicável */
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        .saved-video-item:hover {
            background-color: #eef; /* Leve destaque ao passar o mouse */
            transform: translateY(-2px); /* Efeito de elevação */
        }
        /* Removido o elemento <video> direto dos itens da lista */
        /* Removido video-info, video-actions direto dos itens da lista */

        .saved-video-item .video-name-list { /* Novo estilo para nome na lista */
            font-weight: 700;
            color: #212121;
            font-size: 1.1em; /* Um pouco maior para ser mais visível */
            text-align: center;
            word-break: break-all;
        }
        .saved-video-item .video-date-list { /* Novo estilo para data na lista */
            font-size: 0.9em;
            color: #757575;
            text-align: center;
        }


        .saved-videos-screen .back-button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 20px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .saved-videos-screen .back-button:hover {
            background-color: #0056b3;
        }

        /* ESTILOS PARA A NOVA TELA DE REPRODUÇÃO DE VÍDEO */
        .video-player-screen {
            display: none; /* Controlado via JS */
            width: 100%;
            max-width: 600px; /* Maior para o player */
            gap: 20px;
        }
        .video-player-screen video {
            width: 100%;
            height: auto;
            max-height: 350px; /* Altura máxima do player */
            background-color: black;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        .video-player-screen .video-details {
            text-align: center;
            width: 100%;
        }
        .video-player-screen .video-details p {
            margin: 5px 0;
        }
        .video-player-screen .video-details .video-name {
            font-weight: 700;
            font-size: 1.3em;
            color: #333;
        }
        .video-player-screen .video-details .video-date {
            font-size: 0.9em;
            color: #666;
        }
        .video-player-screen .player-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            width: 100%;
            flex-wrap: wrap; /* Para quebrar em várias linhas em telas pequenas */
        }
        .video-player-screen .player-actions button {
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .video-player-screen .player-actions .btn-download-player {
            background-color: #4CAF50;
            color: white;
        }
        .video-player-screen .player-actions .btn-download-player:hover {
            background-color: #66BB6A;
            transform: translateY(-1px);
        }
        .video-player-screen .player-actions .btn-delete-player {
            background-color: #f44336;
            color: white;
        }
        .video-player-screen .player-actions .btn-delete-player:hover {
            background-color: #ef5350;
            transform: translateY(-1px);
        }
        .video-player-screen .back-to-list-button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 20px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .video-player-screen .back-to-list-button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <!-- Botão Sair Fixo no Canto Superior Direito -->
    <button id="topRightLogoutButton" class="hidden">Sair</button>

    <!-- Tela de Login -->
    <div id="loginScreen" class="login-screen">
        <h2 class="text-center">Acesso ao App de Segurança</h2>
        <p class="text-gray-600 text-center">Por favor, faça login com sua conta Google para continuar.</p>
        <!-- Novo botão para login com Google via Firebase -->
        <button id="googleSignInButton" class="mt-4">
            <img src="https://img.icons8.com/color/48/000000/google-logo.png" alt="Google logo"/>
            Entrar com Google
        </button>
        <p class="text-xs text-blue-500 mt-4">
            * O login do Google é gerenciado pelo Firebase Authentication.
            Certifique-se de que o provedor Google esteja ativado em seu projeto Firebase.
        </p>
    </div>

    <!-- Tela Principal do Aplicativo (inicialmente oculta) -->
    <div id="appScreen" class="app-screen container">
        <h1 class="text-2xl font-bold text-gray-800 mb-3">
            App de Segurança do Motorista
        </h1>

        <!-- O ID do Usuário para depuração permanece dentro do appScreen -->
        <p id="userIdDisplay" class="text-xs text-gray-500 mt-2">ID do Usuário: <span id="userIdValue">N/A</span></p>

        <div class="video-group">
            <div class="video-preview">
                <h2 class="text-lg font-semibold text-gray-700 mb-2">Câmera Interna (Frontal)</h2>
                <div class="video-wrapper">
                    <video id="internalCameraFeed" autoplay muted playsinline></video>
                    <div id="internalRecordingOverlay" class="recording-overlay">
                        <span class="recording-dot"></span>
                        <span id="internalRecordingTimer">00:00</span>
                    </div>
                </div>
            </div>
            <div class="video-preview">
                <h2 class="text-lg font-semibold text-gray-700 mb-2">Câmera Externa (Traseira)</h2>
                <div class="video-wrapper">
                    <video id="externalCameraFeed" autoplay muted playsinline></video>
                    <div id="externalRecordingOverlay" class="recording-overlay">
                        <span class="recording-dot"></span>
                        <span id="externalRecordingTimer">00:00</span>
                    </div>
                </div>
                <p class="text-sm text-gray-500 mt-2">
                    *Gravação simultânea e em segundo plano é uma simulação. Para funcionalidade real, um aplicativo nativo é essencial.
                </p>
            </div>
        </div>

        <div class="controls">
            <button id="startButton" class="button button-primary">Iniciar Gravação</button>
            <button id="stopButton" class="button button-secondary" disabled>Parar Gravação</button>
            <button id="panicButton" class="button button-danger span-full">Pânico!</button>
            <!-- Novo botão para ir para a tela de vídeos salvos -->
            <button id="viewSavedVideosButton" class="button button-secondary span-full">Ver Vídeos Salvos</button>
        </div>

        <div id="messageBox" class="message-box"></div>
    </div>

    <!-- Modal para Opções de Salvamento -->
    <div id="saveModalOverlay" class="save-modal-overlay">
        <div class="save-modal-content">
            <h3>Salvar os vídeos no telefone?</h3>
            <div class="save-modal-actions">
                <button id="saveToPhoneButton" class="btn-save-phone">Salvar no Telefone</button>
                <button id="cancelSaveButton" class="btn-cancel-save">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Nova Tela para Vídeos Salvos (inicialmente oculta) -->
    <div id="savedVideosScreen" class="saved-videos-screen">
        <h2 class="text-center">Vídeos Salvos</h2>
        <div id="savedVideosList" class="saved-videos-list">
            <!-- Os nomes dos vídeos salvos serão injetados aqui pelo JavaScript como itens clicáveis -->
            <p class="text-gray-500 text-center mt-4" id="noVideosMessage">Nenhum vídeo salvo ainda.</p>
        </div>
        <button id="backToAppButton" class="back-button">
            <i class="fas fa-arrow-left"></i> Voltar
        </button>
    </div>

    <!-- NOVA TELA: Reprodução de Vídeo Individual -->
    <div id="videoPlayerScreen" class="video-player-screen container">
        <h2 class="text-center">Reprodução de Vídeo</h2>
        <video id="currentVideoPlayer" controls autoplay playsinline class="w-full"></video>
        <div class="video-details">
            <p id="currentVideoName" class="video-name"></p>
            <p id="currentVideoDate" class="video-date"></p>
        </div>
        <div class="player-actions">
            <button id="downloadCurrentVideoButton" class="btn-download-player"><i class="fas fa-download"></i> Baixar</button>
            <button id="deleteCurrentVideoButton" class="btn-delete-player"><i class="fas fa-trash-alt"></i> Excluir</button>
        </div>
        <button id="backToSavedVideosListButton" class="back-to-list-button">
            <i class="fas fa-arrow-left"></i> Voltar para a Lista
        </button>
    </div>


    <!-- Script principal do aplicativo: Consolidado e movido para o final do body -->
    <script type="module">
        // Importações do Firebase Auth, Core e Firestore (Firestore não mais usado diretamente para vídeos)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; // Mantido para compatibilidade, mas não usado para vídeos

        // SUA CONFIGURAÇÃO DO FIREBASE (INSERIDA DIRETAMENTE)
        const firebaseConfig = {
            apiKey: "AIzaSyA0ZeiPVFXpfh3_XdP1AZ4uIBWNebLtnyc",
            authDomain: "camera-de-seguranca-ad986.firebaseapp.com",
            projectId: "camera-de-seguranca-ad986",
            storageBucket: "camera-de-seguranca-ad986.firebasestorage.app",
            messagingSenderId: "778511094601",
            appId: "1:778511094601:web:9f3dcf0ed3f88a06238098",
            measurementId: "G-6BQB06936N"
        };

        // A variável __app_id é fornecida pelo ambiente Canvas (ainda usada para Firestore paths)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Inicializa o Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app); // Inicializa Firestore (mantido)

        // Variáveis de estado da câmera e gravação
        let mediaRecorderInternal;
        let mediaRecorderExternal;
        let internalCameraStream;
        let externalCameraStream;
        let recordedChunksInternal = [];
        let recordedChunksExternal = [];
        let isRecording = false; // Flag para controlar se ALGUMA gravação está ativa
        let currentUserId = null; // Para armazenar o ID do usuário logado
        let currentUserEmail = null; // Para armazenar o e-mail do usuário logado

        let timerInterval;
        let secondsRecorded = 0;

        // Armazena os blobs de vídeo para acesso posterior no modal (temporário durante a gravação)
        let internalVideoBlob = null;
        let externalVideoBlob = null;

        // Variável para armazenar o ID do vídeo atualmente sendo reproduzido
        let currentlyPlayingVideoId = null;


        // --- Funções de Utilitários ---

        // Função para formatar o tempo em MM:SS
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Função para formatar a data e hora atual para o nome do arquivo e exibição
        function formatDateTimeForFilename() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
        }

        // Função para iniciar o cronômetro e mostrar overlays
        function startTimerAndShowOverlays() {
            secondsRecorded = 0;
            internalRecordingTimer.textContent = formatTime(secondsRecorded);
            externalRecordingTimer.textContent = formatTime(secondsRecorded);

            // Ativa os overlays apenas se houver streams ativas
            if (internalCameraStream) internalRecordingOverlay.classList.add('active');
            if (externalCameraStream) externalRecordingOverlay.classList.add('active');

            timerInterval = setInterval(() => {
                secondsRecorded++;
                internalRecordingTimer.textContent = formatTime(secondsRecorded);
                externalRecordingTimer.textContent = formatTime(secondsRecorded);
            }, 1000);
        }

        // Função para parar o cronômetro e esconder todos os overlays
        function stopTimerAndHideOverlays() {
            clearInterval(timerInterval);
            secondsRecorded = 0;
            internalRecordingTimer.textContent = '00:00';
            externalRecordingTimer.textContent = '00:00';
            internalRecordingOverlay.classList.remove('active');
            externalRecordingOverlay.classList.remove('active');
        }

        // Função para exibir mensagens ao usuário
        function showMessageBox(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            messageBox.classList.add('block');

            messageBox.style.backgroundColor = '';
            messageBox.style.color = '';

            if (type === 'error') {
                messageBox.style.backgroundColor = '#ffcdd2'; // Light red
                messageBox.style.color = '#c62828'; // Dark red
            } else if (type === 'success') {
                messageBox.style.backgroundColor = '#c8e6c9'; // Light green
                messageBox.style.color = '#2e7d32'; // Dark green
            } else if (type === 'danger') {
                messageBox.style.backgroundColor = '#ffcdd2'; // Light red
                messageBox.style.color = '#c62828'; // Dark red
            } else if (type === 'authentic') {
                messageBox.style.backgroundColor = '#bbdefb'; /* Azul claro */
                messageBox.style.color = '#1976d2'; /* Azul escuro */
            } else { // info
                messageBox.style.backgroundColor = '#ffe0b2'; // Light orange
                messageBox.style.color = '#e65100'; // Dark orange
            }
            setTimeout(() => {
                messageBox.classList.remove('block');
                messageBox.classList.add('hidden');
            }, 5000);
        }

        // Gerencia o estado dos botões Iniciar/Parar
        function updateButtonStates() {
            startButton.disabled = isRecording;
            stopButton.disabled = !isRecording;
        }

        // Função para parar gravação e streams (centralizada para evitar repetição)
        function stopSimultaneousRecording() {
            if (isRecording) {
                if (mediaRecorderInternal && mediaRecorderInternal.state !== 'inactive') {
                    mediaRecorderInternal.stop();
                }
                if (mediaRecorderExternal && mediaRecorderExternal.state !== 'inactive') {
                    mediaRecorderExternal.stop();
                }
                isRecording = false;
                stopTimerAndHideOverlays();
                updateButtonStates();
            }
        }

        // Função para parar todas as streams das câmeras (centralizada para evitar repetição)
        function stopCameraStreams() {
            if (internalCameraStream) {
                internalCameraStream.getTracks().forEach(track => track.stop());
                internalCameraFeed.srcObject = null;
                internalCameraStream = null;
            }
            if (externalCameraStream) {
                externalCameraStream.getTracks().forEach(track => track.stop());
                externalCameraFeed.srcObject = null;
                externalCameraStream = null;
            }
            console.log('Streams das câmeras paradas.');
        }


        // --- Funções de Controle de Câmera e Gravação ---

        // Função para iniciar as streams das câmeras para visualização
        async function startCameraStreams() {
            stopCameraStreams();

            let internalCameraSuccess = false;
            let externalCameraSuccess = false;

            try {
                internalCameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' },
                    audio: true
                });
                internalCameraFeed.srcObject = internalCameraStream;
                showMessageBox('Câmera interna (frontal) ativada.', 'success');
                internalCameraSuccess = true;
            } catch (err) {
                console.error('Erro ao acessar a câmera interna:', err);
                showMessageBox(`Erro ao iniciar a câmera interna: ${err.name} - ${err.message}. Verifique as permissões.`, 'error');
            }

            try {
                externalCameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                externalCameraFeed.srcObject = externalCameraStream;
                showMessageBox('Câmera externa (traseira) ativada.', 'success');
                externalCameraSuccess = true;
            } catch (err) {
                console.error('Erro ao acessar a câmera externa:', err);
                showMessageBox(`Erro ao iniciar a câmera externa: ${err.name} - ${err.message}. Verifique as permissões.`, 'error');
            }

            if (internalCameraSuccess || externalCameraSuccess) {
                startButton.disabled = false;
            } else {
                startButton.disabled = true;
            }
            updateButtonStates();
        }

        // Função para iniciar a gravação de AMBAS as câmeras (simulação)
        function startSimultaneousRecording() {
            if (isRecording) {
                showMessageBox('A gravação já está em andamento.', 'info');
                return;
            }

            let recordingStarted = false;

            // Zera os blobs anteriores ao iniciar nova gravação
            internalVideoBlob = null;
            externalVideoBlob = null;
            recordedChunksInternal = [];
            recordedChunksExternal = [];

            if (internalCameraStream) {
                try {
                    mediaRecorderInternal = new MediaRecorder(internalCameraStream);
                    mediaRecorderInternal.ondataavailable = (event) => {
                        if (event.data.size > 0) recordedChunksInternal.push(event.data);
                    };
                    mediaRecorderInternal.onstop = () => {
                        internalVideoBlob = new Blob(recordedChunksInternal, { type: 'video/webm' });
                        console.log('Gravação interna finalizada. Blob:', internalVideoBlob);
                        showMessageBox('Gravação da câmera interna finalizada.', 'info');
                        // No cenário real, aqui você processaria ou faria upload do blob
                    };
                    mediaRecorderInternal.start();
                    showMessageBox('Gravação da câmera interna iniciada.', 'success');
                    recordingStarted = true;
                } catch (e) {
                    console.error('Erro ao iniciar gravação interna:', e);
                    showMessageBox('Erro ao iniciar gravação da câmera interna.', 'error');
                }
            } else {
                showMessageBox('Câmera interna não ativa para gravação.', 'info');
            }

            if (externalCameraStream) {
                try {
                    mediaRecorderExternal = new MediaRecorder(externalCameraStream);
                    mediaRecorderExternal.ondataavailable = (event) => {
                        if (event.data.size > 0) recordedChunksExternal.push(event.data);
                    };
                    mediaRecorderExternal.onstop = () => {
                        externalVideoBlob = new Blob(recordedChunksExternal, { type: 'video/webm' });
                        console.log('Gravação externa finalizada. Blob:', externalVideoBlob);
                        showMessageBox('Gravação da câmera externa finalizada.', 'info');
                        // No cenário real, aqui você processaria ou faria upload do blob
                    };
                    mediaRecorderExternal.start();
                    showMessageBox('Gravação da câmera externa iniciada.', 'success');
                    recordingStarted = true;
                } catch (e) {
                    console.error('Erro ao iniciar gravação externa:', e);
                    showMessageBox('Erro ao iniciar gravação da câmera externa.', 'error');
                }
            } else {
                showMessageBox('Câmera externa não ativa para gravação.', 'info');
            }

            if (recordingStarted) {
                isRecording = true;
                startTimerAndShowOverlays();
                updateButtonStates();
                showMessageBox('Gravação de segurança iniciada.', 'success');
            } else {
                showMessageBox('Nenhuma câmera disponível para iniciar a gravação.', 'error');
            }
        }

        // Função para parar a gravação e exibir modal de salvamento
        function stopRecordingAndShowSaveOptions() {
            if (!isRecording) {
                showMessageBox('Nenhuma gravação em andamento para parar.', 'info');
                return;
            }

            stopSimultaneousRecording(); // Usa a função centralizada
            
            showMessageBox('Gravação de segurança parada. Escolha uma opção para salvar.', 'info');

            // Exibe o modal de salvamento
            saveModalOverlay.classList.add('active');
        }

        // Funções do IndexedDB
        let dbRequest;
        let dbInstance;
        const DB_NAME = 'VideoStorageDB';
        const DB_VERSION = 1;
        const OBJECT_STORE_NAME = 'videos';

        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                dbRequest = indexedDB.open(DB_NAME, DB_VERSION);

                dbRequest.onupgradeneeded = (event) => {
                    dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(OBJECT_STORE_NAME)) {
                        dbInstance.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });
                    }
                };

                dbRequest.onsuccess = (event) => {
                    dbInstance = event.target.result;
                    resolve(dbInstance);
                };

                dbRequest.onerror = (event) => {
                    console.error('Erro ao abrir IndexedDB:', event.target.errorCode);
                    showMessageBox('Erro ao abrir o banco de dados de vídeos. Os vídeos salvos podem não ser persistentes.', 'error');
                    reject(event.target.errorCode);
                };
            });
        }

        async function addVideoToIndexedDB(videoData) {
            try {
                const db = await openIndexedDB();
                const transaction = db.transaction([OBJECT_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(OBJECT_STORE_NAME);
                const request = store.add(videoData);

                request.onsuccess = () => {
                    console.log('Vídeo adicionado ao IndexedDB:', videoData.id);
                };

                request.onerror = (event) => {
                    console.error('Erro ao adicionar vídeo ao IndexedDB:', event.target.errorCode);
                    showMessageBox('Erro ao salvar vídeo no navegador. Pode não ser exibido na lista.', 'error');
                };
            } catch (error) {
                console.error('Erro na operação IndexedDB:', error);
            }
        }

        async function getVideosFromIndexedDB() {
            return new Promise(async (resolve, reject) => {
                try {
                    const db = await openIndexedDB();
                    const transaction = db.transaction([OBJECT_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(OBJECT_STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        resolve(request.result);
                    };

                    request.onerror = (event) => {
                        console.error('Erro ao buscar vídeos do IndexedDB:', event.target.errorCode);
                        showMessageBox('Erro ao carregar vídeos salvos.', 'error');
                        reject(event.target.errorCode);
                    };
                } catch (error) {
                    console.error('Erro ao acessar IndexedDB para buscar:', error);
                    reject(error);
                }
            });
        }

        // Função para obter um vídeo específico por ID
        async function getVideoById(id) {
            return new Promise(async (resolve, reject) => {
                try {
                    const db = await openIndexedDB();
                    const transaction = db.transaction([OBJECT_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(OBJECT_STORE_NAME);
                    const request = store.get(id);

                    request.onsuccess = () => {
                        resolve(request.result);
                    };

                    request.onerror = (event) => {
                        console.error('Erro ao buscar vídeo por ID do IndexedDB:', event.target.errorCode);
                        showMessageBox('Erro ao carregar o vídeo selecionado.', 'error');
                        reject(event.target.errorCode);
                    };
                } catch (error) {
                    console.error('Erro ao acessar IndexedDB para buscar por ID:', error);
                    reject(error);
                }
            });
        }

        async function deleteVideoFromIndexedDB(id) {
            try {
                const db = await openIndexedDB();
                const transaction = db.transaction([OBJECT_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(OBJECT_STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => {
                    console.log('Vídeo removido do IndexedDB:', id);
                    showMessageBox('Vídeo removido com sucesso.', 'success');
                    // Se estiver na tela de player, volta para a lista após excluir
                    if (currentlyPlayingVideoId === id) {
                        showScreen('savedVideos'); // Volta para a lista
                        // Limpa o player imediatamente
                        currentVideoPlayer.pause();
                        currentVideoPlayer.removeAttribute('src');
                        currentlyPlayingVideoId = null;
                    }
                    displaySavedVideos(); // Recarrega a lista
                };

                request.onerror = (event) => {
                    console.error('Erro ao remover vídeo do IndexedDB:', event.target.errorCode);
                    showMessageBox('Erro ao remover vídeo.', 'error');
                };
            } catch (error) {
                console.error('Erro ao acessar IndexedDB para remover:', error);
            }
        }


        // Função para salvar no Telefone (dispara download e armazena Blob no IndexedDB)
        async function saveToPhone() {
            saveModalOverlay.classList.remove('active'); // Esconde o modal
            let savedCount = 0;
            const dateTime = formatDateTimeForFilename(); // Obtém a data e hora para o nome
            const videoIdBase = `${currentUserId || 'anonymous'}_${Date.now()}`; // ID base único para o vídeo no IndexedDB

            if (internalVideoBlob) {
                const internalFileName = `video_interno_${dateTime}.webm`;
                const internalVideoId = `${videoIdBase}_internal`;
                // Dispara download
                const url = URL.createObjectURL(internalVideoBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = internalFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Libera o URL do objeto imediatamente
                savedCount++;

                // Adiciona ao IndexedDB
                await addVideoToIndexedDB({
                    id: internalVideoId,
                    name: internalFileName,
                    date: new Date().toLocaleString(),
                    type: 'internal',
                    blob: internalVideoBlob // Salva o Blob completo
                });
            }

            if (externalVideoBlob) {
                const externalFileName = `video_externo_${dateTime}.webm`;
                const externalVideoId = `${videoIdBase}_external`;
                // Dispara download
                const url = URL.createObjectURL(externalVideoBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = externalFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Libera o URL do objeto imediatamente
                savedCount++;

                // Adiciona ao IndexedDB
                await addVideoToIndexedDB({
                    id: externalVideoId,
                    name: externalFileName,
                    date: new Date().toLocaleString(),
                    type: 'external',
                    blob: externalVideoBlob // Salva o Blob completo
                });
            }

            if (savedCount > 0) {
                showMessageBox(`Vídeos salvos no seu telefone (${savedCount} arquivos) e no navegador.`, 'success');
            } else {
                showMessageBox('Nenhum vídeo disponível para salvar.', 'info');
            }
            // Resetar blobs após salvamento
            internalVideoBlob = null;
            externalVideoBlob = null;

            // Recarregar a lista de vídeos salvos caso o usuário navegue para essa tela
            displaySavedVideos(); // Garante que a lista esteja atualizada se o usuário for para lá
        }

        // Função para cancelar o salvamento
        function cancelSave() {
            saveModalOverlay.classList.remove('active'); // Esconde o modal
            showMessageBox('Salvamento cancelado. Os vídeos não foram salvos.', 'info');
            // Resetar blobs, pois o usuário decidiu não salvá-los
            internalVideoBlob = null;
            externalVideoBlob = null;
        }

        // Função para exibir a lista de vídeos salvos (agora sem <video>s diretos)
        async function displaySavedVideos() {
            savedVideosList.innerHTML = ''; // Limpa a lista existente
            const savedVideos = await getVideosFromIndexedDB();

            if (savedVideos.length === 0) {
                noVideosMessage.classList.remove('hidden');
                // Certifica-se de que a mensagem "Nenhum vídeo salvo ainda" é o único conteúdo
                savedVideosList.appendChild(noVideosMessage);
            } else {
                noVideosMessage.classList.add('hidden'); // Oculta a mensagem "Nenhum vídeo salvo"
                savedVideos.forEach(video => {
                    const videoItem = document.createElement('div');
                    videoItem.classList.add('saved-video-item');
                    videoItem.dataset.videoId = video.id; // Armazena o ID para acesso posterior
                    
                    // Adiciona um evento de clique para abrir o player
                    videoItem.onclick = () => playVideo(video.id);

                    videoItem.innerHTML = `
                        <p class="video-name-list">${video.name}</p>
                        <p class="video-date-list">Gravado em: ${video.date}</p>
                    `;
                    savedVideosList.appendChild(videoItem);
                });
            }
        }

        // NOVA FUNÇÃO: Reproduz um vídeo específico pelo ID do IndexedDB
        async function playVideo(videoId) {
            const videoData = await getVideoById(videoId);
            if (videoData && videoData.blob) {
                currentlyPlayingVideoId = videoId; // Armazena o ID do vídeo atual
                const videoUrl = URL.createObjectURL(videoData.blob);
                currentVideoPlayer.src = videoUrl;
                currentVideoPlayer.load(); // Garante que o vídeo seja carregado
                currentVideoPlayer.play(); // Tenta iniciar a reprodução automaticamente

                currentVideoNameDisplay.textContent = videoData.name;
                currentVideoDateDisplay.textContent = `Gravado em: ${videoData.date}`;
                
                // Evento para liberar o URL do objeto Blob quando o vídeo puder ser reproduzido
                // Usamos 'canplay' para garantir que o navegador já processou o blob e está pronto para liberar
                currentVideoPlayer.oncanplay = () => {
                    // CUIDADO: Se o vídeo for pausado e depois reproduzido, um novo URL pode ser criado.
                    // Para simplificar, revocamos apenas uma vez aqui.
                    // Em apps mais complexos, gerenciar URLs de Blob para reprodução é mais granular.
                    URL.revokeObjectURL(videoUrl); 
                };

                // Adiciona event listeners para os botões de download e delete na tela do player
                downloadCurrentVideoButton.onclick = () => {
                    const urlToDownload = URL.createObjectURL(videoData.blob); // Cria um novo URL para download
                    const a = document.createElement('a');
                    a.href = urlToDownload;
                    a.download = videoData.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(urlToDownload); // Libera o URL do download
                    showMessageBox(`Baixando: ${videoData.name}`, 'info');
                };

                deleteCurrentVideoButton.onclick = () => {
                    // Usa o 'confirm' do navegador que é visível
                    if (confirm(`Tem certeza que deseja excluir o vídeo "${videoData.name}"?`)) {
                        currentVideoPlayer.pause(); // Pausa o vídeo antes de excluir
                        currentVideoPlayer.removeAttribute('src'); // Limpa a fonte do player para liberar memória
                        deleteVideoFromIndexedDB(currentlyPlayingVideoId); // Exclui do IndexedDB
                        currentlyPlayingVideoId = null; // Limpa o ID do vídeo atual
                        // A função deleteVideoFromIndexedDB chamará displaySavedVideos()
                        // e showScreen('savedVideos') para retornar à lista atualizada.
                    }
                };

                showScreen('videoPlayer'); // Troca para a tela do player
            } else {
                showMessageBox('Vídeo não encontrado ou Blob corrompido.', 'error');
            }
        }

        // Elementos da UI
        // Moved element declarations after function definitions to avoid ReferenceError
        const internalCameraFeed = document.getElementById('internalCameraFeed');
        const externalCameraFeed = document.getElementById('externalCameraFeed');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const panicButton = document.getElementById('panicButton');
        const messageBox = document.getElementById('messageBox');
        const internalRecordingOverlay = document.getElementById('internalRecordingOverlay');
        const internalRecordingTimer = document.getElementById('internalRecordingTimer');
        const externalRecordingOverlay = document.getElementById('externalRecordingOverlay');
        const externalRecordingTimer = document.getElementById('externalRecordingTimer');

        // Elementos da UI de Login
        const loginScreen = document.getElementById('loginScreen');
        const appScreen = document.getElementById('appScreen');
        const googleSignInButton = document.getElementById('googleSignInButton');
        const userIdDisplay = document.getElementById('userIdDisplay'); // Elemento para exibir o User ID
        const userIdValue = document.getElementById('userIdValue'); // Span para o valor do User ID

        // NOVOS ELEMENTOS DA UI FIXOS (SAIR)
        const topRightLogoutButton = document.getElementById('topRightLogoutButton');

        // Elementos do Modal de Salvamento
        const saveModalOverlay = document.getElementById('saveModalOverlay');
        const saveToPhoneButton = document.getElementById('saveToPhoneButton'); // Agora é o único botão de salvamento
        const cancelSaveButton = document.getElementById('cancelSaveButton');

        // Elementos da Nova Tela de Vídeos Salvos
        const savedVideosScreen = document.getElementById('savedVideosScreen');
        const savedVideosList = document.getElementById('savedVideosList');
        const viewSavedVideosButton = document.getElementById('viewSavedVideosButton');
        const backToAppButton = document.getElementById('backToAppButton');
        const noVideosMessage = document.getElementById('noVideosMessage');

        // Elementos da NOVA TELA: Reprodução de Vídeo Individual
        const videoPlayerScreen = document.getElementById('videoPlayerScreen');
        const currentVideoPlayer = document.getElementById('currentVideoPlayer');
        const currentVideoNameDisplay = document.getElementById('currentVideoName');
        const currentVideoDateDisplay = document.getElementById('currentVideoDate');
        const downloadCurrentVideoButton = document.getElementById('downloadCurrentVideoButton');
        const deleteCurrentVideoButton = document.getElementById('deleteCurrentVideoButton');
        const backToSavedVideosListButton = document.getElementById('backToSavedVideosListButton');


        // --- Event Listeners para Botões de Controle ---
        startButton.addEventListener('click', startSimultaneousRecording);
        stopButton.addEventListener('click', stopRecordingAndShowSaveOptions); // Chama a função que exibe o modal
        panicButton.addEventListener('click', () => {
            // Se houver gravação em andamento, pare-a e não mostre o modal de salvamento
            if (isRecording) {
                stopSimultaneousRecording(); // Usa a função centralizada
            }
            showMessageBox('ALERTA DE PÂNICO ATIVADO! Gravação interrompida (simulação de envio de alerta).', 'danger');
            // Resetar blobs após alerta de pânico (não salvos)
            internalVideoBlob = null;
            externalVideoBlob = null;
        });

        // Event Listeners para o Modal de Salvamento
        saveToPhoneButton.addEventListener('click', saveToPhone); // Apenas o botão de salvar no telefone
        cancelSaveButton.addEventListener('click', cancelSave);

        // Event listeners para navegação
        viewSavedVideosButton.addEventListener('click', () => {
            showScreen('savedVideos'); // Vai para a tela de vídeos salvos
            displaySavedVideos(); // Atualiza a lista quando a tela é mostrada
        });
        backToAppButton.addEventListener('click', () => {
            showScreen('app'); // Volta para a tela principal do aplicativo
        });

        // Event Listener para o botão de voltar na tela do player
        backToSavedVideosListButton.addEventListener('click', () => {
            currentVideoPlayer.pause(); // Pausa o vídeo antes de sair da tela
            currentVideoPlayer.removeAttribute('src'); // Limpa a fonte para liberar memória
            currentlyPlayingVideoId = null; // Limpa o ID do vídeo atual
            showScreen('savedVideos'); // Volta para a lista de vídeos salvos
            displaySavedVideos(); // Garante que a lista esteja atualizada
        });

        // --- Funções de Login e Logout do Firebase ---

        // Função para mostrar a tela correta (login, app, savedVideos ou videoPlayer)
        function showScreen(screenId) {
            loginScreen.style.display = 'none';
            appScreen.style.display = 'none';
            savedVideosScreen.style.display = 'none';
            videoPlayerScreen.style.display = 'none'; // Nova tela do player
            topRightLogoutButton.classList.add('hidden'); // Oculta por padrão

            // Pausa streams e gravação ao mudar de tela (a menos que esteja indo para appScreen)
            if (screenId !== 'app') {
                stopSimultaneousRecording(); // Garante que a gravação pare
                stopCameraStreams(); // Para as streams da câmera
            }

            switch (screenId) {
                case 'login':
                    loginScreen.style.display = 'flex';
                    break;
                case 'app':
                    appScreen.style.display = 'flex';
                    topRightLogoutButton.classList.remove('hidden');
                    startCameraStreams(); // Inicia as câmeras apenas quando o app está visível
                    break;
                case 'savedVideos':
                    savedVideosScreen.style.display = 'flex';
                    topRightLogoutButton.classList.remove('hidden'); // Mantém o botão Sair visível
                    break;
                case 'videoPlayer':
                    videoPlayerScreen.style.display = 'flex';
                    topRightLogoutButton.classList.remove('hidden'); // Mantém o botão Sair visível
                    break;
            }
        }

        // Event listener para o botão de login do Google
        googleSignInButton.addEventListener('click', async () => {
            const provider = new GoogleAuthProvider();
            try {
                // Tenta fazer login com um pop-up
                const result = await signInWithPopup(auth, provider);
                const user = result.user;
                console.log("Usuário logado:", user);
                // onAuthStateChanged irá lidar com a atualização da UI
            } catch (error) {
                console.error("Erro no login com Google:", error);
                let errorMessage = "Erro desconhecido ao tentar login com Google.";
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Login cancelado. O pop-up de login foi fechado.";
                } else if (error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Login cancelado. Já havia uma solicitação de pop-up.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "O login com Google não está ativado. Ative-o nas configurações de autenticação do Firebase.";
                } else if (error.code === 'auth/auth-domain-config-error') {
                    errorMessage = "Erro de configuração de domínio de autenticação. Verifique os domínios autorizados no Firebase.";
                }
                showMessageBox(`Erro de login: ${errorMessage}`, 'error');
            }
        });

        // Event listener para o botão de logout fixo
        topRightLogoutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
                console.log("Usuário deslogado.");
                // onAuthStateChanged irá lidar com a atualização da UI
            } catch (error) {
                console.error("Erro ao deslogar:", error);
                showMessageBox(`Erro ao deslogar: ${error.message}`, 'error');
            }
        });

        // --- Gerenciamento de Estado de Autenticação com Firebase ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                // Usuário está logado
                currentUserId = user.uid; // Define o ID do usuário logado
                currentUserEmail = user.email; // Armazena o e-mail do usuário logado
                userIdValue.textContent = currentUserId; // Exibe o ID do usuário no appScreen
                showScreen('app'); // Mostra a tela principal
                showMessageBox(`Bem-vindo(a), ${user.displayName || 'Usuário'}!`, 'success');

            } else {
                // Usuário não está logado
                currentUserId = null; // Limpa o ID do usuário
                currentUserEmail = null; // Limpa o e-mail
                userIdValue.textContent = "N/A"; // Limpa o ID do usuário no display
                showScreen('login'); // Mostra a tela de login
            }
            updateButtonStates();
        });
        
    </script>
</body>
</html>
