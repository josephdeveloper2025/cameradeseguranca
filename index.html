<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App Segurança Motorista</title>
    <!-- Inclui Tailwind CSS para estilização rápida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Icones para o botão "Voltar" e "Download" -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Link para o Manifest do PWA -->
    <link rel="manifest" href="/manifest.json">
    <!-- Meta tags para compatibilidade PWA em diferentes navegadores -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="App Seg Motorista">
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
    <meta name="theme-color" content="#4CAF50"/>


    <style>
        /* Estilos base para o corpo da página */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Garante que ocupe a altura total da viewport */
            margin: 0;
            padding: 10px; /* Padding geral */
            box-sizing: border-box;
        }
        /* Container principal do aplicativo */
        .container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            width: 100%;
            max-width: 680px; /* Largura máxima um pouco maior para telas grandes */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px; /* Padding ajustado */
            gap: 15px; /* Espaçamento entre seções */
        }
        /* Estilos para o grupo de vídeos (câmeras) */
        .video-group {
            display: flex;
            flex-direction: column; /* Padrão: vídeos empilhados para mobile */
            width: 100%;
            gap: 12px; /* Espaçamento entre os vídeos */
        }
        /* Estilos para a pré-visualização de cada vídeo */
        .video-preview {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            border-radius: 10px;
            overflow: hidden;
        }
        /* Wrapper para manter o aspecto ratio do vídeo (16:9) */
        .video-wrapper {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio (9 / 16 * 100%) */
            background-color: #2c3e50; /* Cor escura para preencher enquanto vídeo não carrega */
            border-radius: 10px;
            overflow: hidden;
        }
        /* Estilos para o elemento de vídeo dentro do wrapper de aspecto ratio */
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 2px solid #ddd;
            display: block;
        }
        /* Responsividade para telas maiores (tablets e desktops) */
        @media (min-width: 600px) { /* Breakpoint ligeiramente menor para Tablets */
            .video-group {
                flex-direction: row; /* Vídeos lado a lado */
                justify-content: space-between; /* Espaço entre os vídeos */
            }
            .video-preview {
                width: 49%; /* Ajuste para ter um pequeno gap no meio */
            }
        }
        /* Controles (botões) */
        .controls {
            display: grid; /* Usando grid para melhor controle de layout */
            grid-template-columns: 1fr; /* Uma coluna por padrão para mobile */
            gap: 10px; /* Espaçamento entre os botões */
            width: 100%;
        }
        /* Responsividade para botões em telas maiores */
        @media (min-width: 400px) { /* A partir de uma largura de celular um pouco maior */
            .controls {
                grid-template-columns: 1fr 1fr; /* Duas colunas */
            }
            .button.span-full { /* Botão Pânico ocupa toda a linha */
                grid-column: 1 / -1;
            }
        }
        @media (min-width: 600px) { /* Para tablets e desktops */
            .controls {
                grid-template-columns: repeat(3, 1fr); /* Três colunas */
            }
        }

        /* Estilos gerais dos botões */
        .button {
            padding: 12px 15px; /* Padding ajustado para otimizar espaço */
            border-radius: 10px;
            font-size: 0.95em; /* Fonte ligeiramente menor para otimização de espaço */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
            white-space: nowrap; /* Evita que o texto quebre em várias linhas */
        }
        .button-primary {
            background-image: linear-gradient(to right, #4CAF50, #66BB6A);
            color: white;
            border: none;
        }
        .button-primary:hover {
            background-image: linear-gradient(to right, #66BB6A, #81C784);
            transform: translateY(-1px);
        }
        .button-danger {
            background-image: linear-gradient(to right, #f44336, #ef5350);
            color: white;
            border: none;
        }
        .button-danger:hover {
            background-image: linear-gradient(to right, #ef5350, #e57373);
            transform: translateY(-1px);
        }
        .button-secondary {
            background-color: #e0e0e0;
            color: #333;
            border: 1px solid #ccc;
        }
        .button-secondary:hover {
            background-color: #d0d0d0;
        }
        /* Caixa de mensagens */
        .message-box {
            background-color: #ffe0b2;
            color: #e65100;
            padding: 10px; /* Padding reduzido */
            border-radius: 8px;
            text-align: center;
            width: 100%;
            font-weight: 500;
            margin-top: 8px;
            display: none; /* Controlado por JS */
            font-size: 0.9em; /* Fonte menor */
            word-wrap: break-word; /* Garante que o texto longo se ajuste */
        }
        /* Overlay de gravação (cronômetro e indicador) */
        .recording-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            background-color: rgba(0, 0, 0, 0.65);
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.8em; /* Fonte menor para caber melhor */
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 10;
            display: none; /* Controlado por JS */
        }
        .recording-overlay.active {
            display: flex;
        }
        /* Ponto de gravação pulsante */
        .recording-dot {
            width: 8px;
            height: 8px;
            background-color: red;
            border-radius: 50%;
            animation: pulse 1s infinite alternate;
        }
        /* Animação de pulso */
        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }

        /* --- Estilos para as telas de Login e App --- */
        .login-screen, .app-screen, .saved-videos-screen, .video-player-screen {
            display: none; /* Controlado via JS */
            width: 100%;
            max-width: 500px;
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .login-screen h2, .saved-videos-screen h2, .video-player-screen h2 {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
        }

        /* ESTILOS PARA O BOTÃO SAIR NO CANTO SUPERIOR DIREITO */
        #topRightLogoutButton {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 100;
            padding: 8px 15px;
            background-color: #ef5350; /* Vermelho */
            color: white;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
        }
        #topRightLogoutButton:hover {
            background-color: #e53935;
            transform: translateY(-1px);
        }

        /* Estilo para o botão de login do Google (personalizado) */
        #googleSignInButton {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid #dadce0;
            background-color: white;
            font-size: 1.1em;
            font-weight: 500;
            color: #3c4043;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        #googleSignInButton:hover {
            background-color: #f7f7f7;
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        #googleSignInButton img {
            width: 20px;
            height: 20px;
        }

        /* Estilos da Lista de Vídeos Salvos */
        .saved-videos-list {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Mais espaço entre os itens de vídeo */
            max-height: 450px; /* Limita a altura para rolagem */
            overflow-y: auto; /* Adiciona barra de rolagem */
            padding-right: 5px; /* Espaço para a barra de rolagem */
            padding-bottom: 10px; /* Espaço extra no final */
        }
        .saved-video-item {
            background-color: #f8f8f8;
            padding: 15px; /* Mais padding */
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08); /* Sombra mais visível */
            display: flex;
            flex-direction: column;
            align-items: center; /* Centraliza o conteúdo (vídeo e texto) */
            gap: 10px;
            width: 100%;
            cursor: pointer; /* Indica que é clicável */
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        .saved-video-item:hover {
            background-color: #eef; /* Leve destaque ao passar o mouse */
            transform: translateY(-2px); /* Efeito de elevação */
        }

        .saved-video-item .video-name-list { /* Novo estilo para nome na lista */
            font-weight: 700;
            color: #212121;
            font-size: 1.1em; /* Um pouco maior para ser mais visível */
            text-align: center;
            word-break: break-all;
        }
        .saved-video-item .video-date-list { /* Novo estilo para data na lista */
            font-size: 0.9em;
            color: #757575;
            text-align: center;
        }
        .saved-video-item .video-expiration-info { /* Estilo para o tempo de expiração */
            font-size: 0.85em;
            font-weight: 500;
            color: #007bff; /* Azul para destaque */
            margin-top: 5px;
        }
        .saved-video-item .video-expiration-info.expired { /* Estilo para vídeo expirado */
            color: #dc3545; /* Vermelho */
            font-weight: 700;
        }


        .saved-videos-screen .back-button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 20px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .saved-videos-screen .back-button:hover {
            background-color: #0056b3;
        }

        /* ESTILOS PARA A NOVA TELA DE REPRODUÇÃO DE VÍDEO */
        .video-player-screen {
            display: none; /* Controlado via JS */
            width: 100%;
            max-width: 600px; /* Maior para o player */
            gap: 20px;
        }
        .video-player-screen video {
            width: 100%;
            height: auto;
            max-height: 350px; /* Altura máxima do player */
            background-color: black;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        .video-player-screen .video-details {
            text-align: center;
            width: 100%;
        }
        .video-player-screen .video-details p {
            margin: 5px 0;
        }
        .video-player-screen .video-details .video-name {
            font-weight: 700;
            font-size: 1.3em;
            color: #333;
        }
        .video-player-screen .video-details .video-date {
            font-size: 0.9em;
            color: #666;
        }
        .video-player-screen .player-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            width: 100%;
            flex-wrap: wrap; /* Para quebrar em várias linhas em telas pequenas */
        }
        .video-player-screen .player-actions button {
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .video-player-screen .player-actions .btn-download-player {
            background-color: #4CAF50;
            color: white;
        }
        .video-player-screen .player-actions .btn-download-player:hover {
            background-color: #66BB6A;
            transform: translateY(-1px);
        }
        .video-player-screen .player-actions .btn-delete-player {
            background-color: #f44336;
            color: white;
        }
        .video-player-screen .player-actions .btn-delete-player:hover {
            background-color: #ef5350;
            transform: translateY(-1px);
        }
        .video-player-screen .back-to-list-button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 20px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .video-player-screen .back-to-list-button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <!-- Botão Sair Fixo no Canto Superior Direito -->
    <button id="topRightLogoutButton" class="hidden">Sair</button>

    <!-- Tela de Login -->
    <div id="loginScreen" class="login-screen">
        <h2 class="text-center">Acesso ao App de Segurança</h2>
        <p class="text-gray-600 text-center">Por favor, faça login com sua conta Google para continuar.</p>
        <!-- Novo botão para login com Google via Firebase -->
        <button id="googleSignInButton" class="mt-4">
            <img src="https://img.icons8.com/color/48/000000/google-logo.png" alt="Google logo"/>
            Entrar com Google
        </button>
        <p class="text-xs text-blue-500 mt-4">
            * O login do Google é gerenciado pelo Firebase Authentication.
            Certifique-se de que o provedor Google esteja ativado em seu projeto Firebase.
        </p>
    </div>

    <!-- Tela Principal do Aplicativo (inicialmente oculta) -->
    <div id="appScreen" class="app-screen container">
        <h1 class="text-2xl font-bold text-gray-800 mb-3">
            App de Segurança do Motorista
        </h1>

        <!-- O ID do Usuário para depuração permanece dentro do appScreen -->
        <p id="userIdDisplay" class="text-xs text-gray-500 mt-2">ID do Usuário: <span id="userIdValue">N/A</span></p>

        <div class="video-group">
            <div class="video-preview">
                <h2 class="text-lg font-semibold text-gray-700 mb-2">Câmera Interna (Frontal)</h2>
                <div class="video-wrapper">
                    <video id="internalCameraFeed" autoplay muted playsinline></video>
                    <div id="internalRecordingOverlay" class="recording-overlay">
                        <span class="recording-dot"></span>
                        <span id="internalRecordingTimer">00:00</span>
                    </div>
                </div>
            </div>
            <div class="video-preview">
                <h2 class="text-lg font-semibold text-gray-700 mb-2">Câmera Externa (Traseira)</h2>
                <div class="video-wrapper">
                    <video id="externalCameraFeed" autoplay muted playsinline></video>
                    <div id="externalRecordingOverlay" class="recording-overlay">
                        <span class="recording-dot"></span>
                        <span id="externalRecordingTimer">00:00</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="startButton" class="button button-primary">Iniciar Gravação</button>
            <button id="stopButton" class="button button-secondary" disabled>Parar Gravação</button>
            <button id="panicButton" class="button button-danger span-full">Pânico!</button>
            <button id="viewSavedVideosButton" class="button button-secondary span-full">Ver Vídeos Salvos</button>
        </div>

        <div id="messageBox" class="message-box"></div>
    </div>

    <!-- O Modal para Opções de Salvamento foi REMOVIDO -->
    <!-- <div id="saveModalOverlay" class="save-modal-overlay"> ... </div> -->

    <!-- Nova Tela para Vídeos Salvos (inicialmente oculta) -->
    <div id="savedVideosScreen" class="saved-videos-screen">
        <h2 class="text-center">Vídeos Salvos</h2>
        <div id="savedVideosList" class="saved-videos-list">
            <p class="text-gray-500 text-center mt-4" id="noVideosMessage">Nenhum vídeo salvo ainda.</p>
        </div>
        <button id="backToAppButton" class="back-button">
            <i class="fas fa-arrow-left"></i> Voltar
        </button>
    </div>

    <!-- NOVA TELA: Reprodução de Vídeo Individual -->
    <div id="videoPlayerScreen" class="video-player-screen container">
        <h2 class="text-center">Reprodução de Vídeo</h2>
        <video id="currentVideoPlayer" controls autoplay playsinline class="w-full"></video>
        <div class="video-details">
            <p id="currentVideoName" class="video-name"></p>
            <p id="currentVideoDate" class="video-date"></p>
            <p id="currentVideoExpiration" class="video-expiration-info"></p>
        </div>
        <div class="player-actions">
            <button id="downloadCurrentVideoButton" class="btn-download-player"><i class="fas fa-download"></i> Baixar</button>
            <button id="deleteCurrentVideoButton" class="btn-delete-player"><i class="fas fa-trash-alt"></i> Excluir</button>
        </div>
        <button id="backToSavedVideosListButton" class="back-to-list-button">
            <i class="fas fa-arrow-left"></i> Voltar para a Lista
        </button>
    </div>


    <!-- Script principal do aplicativo: Consolidado e movido para o final do body -->
    <script type="module">
        // Importações do Firebase Auth, Core e Firestore
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; 

        // SUA CONFIGURAÇÃO DO FIREBASE (INSERIDA DIRETAMENTE)
        const firebaseConfig = {
            apiKey: "AIzaSyA0ZeiPVFXpfh3_XdP1AZ4uIBWNebLtnyc",
            authDomain: "camera-de-seguranca-ad986.firebaseapp.com",
            projectId: "camera-de-seguranca-ad986",
            storageBucket: "camera-de-seguranca-ad986.firebasestorage.app",
            messagingSenderId: "778511094601",
            appId: "1:778511094601:web:9f3dcf0ed3f88a06238098",
            measurementId: "G-6BQB06936N"
        };

        // A variável __app_id é fornecida pelo ambiente Canvas (ainda usada para Firestore paths)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Inicializa o Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app); 

        // Variáveis de estado da câmera e gravação
        let mediaRecorderInternal;
        let mediaRecorderExternal;
        let internalCameraStream;
        let externalCameraStream;
        let recordedChunksInternal = [];
        let recordedChunksExternal = [];
        let isRecording = false; 
        let currentUserId = null; 
        let currentUserEmail = null; 

        let timerInterval;
        let secondsRecorded = 0;

        // Armazena os blobs de vídeo para acesso posterior no modal (temporário durante a gravação)
        let internalVideoBlob = null;
        let externalVideoBlob = null;

        // Variável para armazenar o ID do vídeo atualmente sendo reproduzido
        let currentlyPlayingVideoId = null;

        // Variável para o intervalo de atualização dos contadores de expiração
        let expirationCheckInterval = null;


        // --- Funções Auxiliares Comuns (definidas no topo para acessibilidade) ---

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function formatDateTimeForFilename() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
        }

        function showMessageBox(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            messageBox.classList.add('block');

            messageBox.style.backgroundColor = '';
            messageBox.style.color = '';

            if (type === 'error') {
                messageBox.style.backgroundColor = '#ffcdd2';
                messageBox.style.color = '#c62828';
            } else if (type === 'success') {
                messageBox.style.backgroundColor = '#c8e6c9';
                messageBox.style.color = '#2e7d32';
            } else if (type === 'danger') {
                messageBox.style.backgroundColor = '#ffcdd2';
                messageBox.style.color = '#c62828';
            } else if (type === 'authentic') {
                messageBox.style.backgroundColor = '#bbdefb';
                messageBox.style.color = '#1976d2';
            } else { // info
                messageBox.style.backgroundColor = '#ffe0b2';
                messageBox.style.color = '#e65100';
            }
            setTimeout(() => {
                messageBox.classList.remove('block');
                messageBox.classList.add('hidden');
            }, 5000);
        }

        function updateButtonStates() {
            startButton.disabled = isRecording;
            stopButton.disabled = !isRecording;
        }

        function startTimerAndShowOverlays() {
            secondsRecorded = 0;
            internalRecordingTimer.textContent = formatTime(secondsRecorded);
            externalRecordingTimer.textContent = formatTime(secondsRecorded);

            if (internalCameraStream) internalRecordingOverlay.classList.add('active');
            if (externalCameraStream) externalRecordingOverlay.classList.add('active');

            timerInterval = setInterval(() => {
                secondsRecorded++;
                internalRecordingTimer.textContent = formatTime(secondsRecorded);
                externalRecordingTimer.textContent = formatTime(secondsRecorded);
            }, 1000);
        }

        function stopTimerAndHideOverlays() {
            clearInterval(timerInterval);
            secondsRecorded = 0;
            internalRecordingTimer.textContent = '00:00';
            externalRecordingTimer.textContent = '00:00';
            internalRecordingOverlay.classList.remove('active');
            externalRecordingOverlay.classList.remove('active');
        }

        // Função para parar gravação e streams (centralizada para evitar repetição)
        function stopSimultaneousRecording() {
            if (isRecording) {
                if (mediaRecorderInternal && mediaRecorderInternal.state !== 'inactive') {
                    mediaRecorderInternal.stop();
                }
                if (mediaRecorderExternal && mediaRecorderExternal.state !== 'inactive') { 
                    mediaRecorderExternal.stop();
                }
                isRecording = false;
                stopTimerAndHideOverlays();
                updateButtonStates();
            }
        }

        // Função para parar todas as streams das câmeras (centralizada para evitar repetição)
        function stopCameraStreams() {
            if (internalCameraStream) {
                internalCameraStream.getTracks().forEach(track => track.stop());
                internalCameraFeed.srcObject = null;
                internalCameraStream = null;
            }
            if (externalCameraStream) {
                externalCameraStream.getTracks().forEach(track => track.stop());
                externalCameraFeed.srcObject = null;
                externalCameraStream = null;
            }
            console.log('Streams das câmeras paradas.');
        }

        // --- Funções do IndexedDB ---
        let dbRequest;
        let dbInstance;
        const DB_NAME = 'VideoStorageDB';
        const DB_VERSION = 1;
        const OBJECT_STORE_NAME = 'videos';
        const EXPIRATION_TIME_MS = 24 * 60 * 60 * 1000; // 24 horas em milissegundos

        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                dbRequest = indexedDB.open(DB_NAME, DB_VERSION);

                dbRequest.onupgradeneeded = (event) => {
                    dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(OBJECT_STORE_NAME)) {
                        dbInstance.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });
                    }
                };

                dbRequest.onsuccess = (event) => {
                    dbInstance = event.target.result;
                    resolve(dbInstance);
                };

                dbRequest.onerror = (event) => {
                    console.error('Erro ao abrir IndexedDB:', event.target.errorCode);
                    showMessageBox('Erro ao abrir o banco de dados de vídeos. Os vídeos salvos podem não ser persistentes.', 'error');
                    reject(event.target.errorCode);
                };
            });
        }

        async function addVideoToIndexedDB(videoData) {
            try {
                const db = await openIndexedDB();
                const transaction = db.transaction([OBJECT_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(OBJECT_STORE_NAME);
                const request = store.add(videoData);

                request.onsuccess = () => {
                    console.log('Vídeo adicionado ao IndexedDB:', videoData.id);
                };

                request.onerror = (event) => {
                    console.error('Erro ao adicionar vídeo ao IndexedDB:', event.target.errorCode);
                    showMessageBox('Erro ao salvar vídeo no navegador. Pode não ser exibido na lista.', 'error');
                };
            } catch (error) {
                console.error('Erro na operação IndexedDB:', error);
            }
        }

        async function getVideosFromIndexedDB() {
            return new Promise(async (resolve, reject) => {
                try {
                    const db = await openIndexedDB();
                    const transaction = db.transaction([OBJECT_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(OBJECT_STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        resolve(request.result);
                    };

                    request.onerror = (event) => {
                        console.error('Erro ao buscar vídeos do IndexedDB:', event.target.errorCode);
                        showMessageBox('Erro ao carregar vídeos salvos.', 'error');
                        reject(event.target.errorCode);
                    };
                } catch (error) {
                    console.error('Erro ao acessar IndexedDB para buscar:', error);
                    reject(error);
                }
            });
        }

        async function getVideoById(id) {
            return new Promise(async (resolve, reject) => {
                try {
                    const db = await openIndexedDB();
                    const transaction = db.transaction([OBJECT_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(OBJECT_STORE_NAME);
                    const request = store.get(id);

                    request.onsuccess = () => {
                        resolve(request.result);
                    };

                    request.onerror = (event) => {
                        console.error('Erro ao buscar vídeo por ID do IndexedDB:', event.target.errorCode);
                        showMessageBox('Erro ao carregar o vídeo selecionado.', 'error');
                        reject(event.target.errorCode);
                    };
                } catch (error) {
                    console.error('Erro ao acessar IndexedDB para buscar por ID:', error);
                    reject(error);
                }
            });
        }

        async function deleteVideoFromIndexedDB(id) {
            try {
                const db = await openIndexedDB();
                const transaction = db.transaction([OBJECT_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(OBJECT_STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => {
                    console.log('Vídeo removido do IndexedDB:', id);
                    showMessageBox('Vídeo removido com sucesso.', 'success');
                    // Se estiver na tela de player, volta para a lista após excluir
                    if (currentlyPlayingVideoId === id) {
                        currentVideoPlayer.pause();
                        currentVideoPlayer.removeAttribute('src');
                        currentlyPlayingVideoId = null;
                        showScreen('savedVideos'); // Volta para a lista
                    }
                    displaySavedVideos(); // Recarrega a lista
                };

                request.onerror = (event) => {
                    console.error('Erro ao remover vídeo do IndexedDB:', event.target.errorCode);
                    showMessageBox('Erro ao remover vídeo.', 'error');
                };
            } catch (error) {
                console.error('Erro ao acessar IndexedDB para remover:', error);
            }
        }

        // --- Funções de Controle de Câmera e Gravação ---

        // Função para iniciar as streams das câmeras para visualização
        async function startCameraStreams() {
            stopCameraStreams();

            let internalCameraSuccess = false;
            let externalCameraSuccess = false;

            try {
                internalCameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' },
                    audio: true 
                });
                internalCameraFeed.srcObject = internalCameraStream;
                showMessageBox('Câmera interna (frontal) ativada.', 'success');
                internalCameraSuccess = true;
            } catch (err) {
                console.error('Erro ao acessar a câmera interna:', err);
                showMessageBox(`Erro ao iniciar a câmera interna: ${err.name} - ${err.message}. Verifique as permissões.`, 'error');
            }

            try {
                externalCameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: true 
                });
                externalCameraFeed.srcObject = externalCameraStream;
                showMessageBox('Câmera externa (traseira) ativada.', 'success');
                externalCameraSuccess = true;
            } catch (err) {
                console.error('Erro ao iniciar a câmera externa:', err);
                showMessageBox(`Erro ao iniciar a câmera externa: ${err.name} - ${err.message}. Verifique as permissões.`, 'error');
            }

            if (internalCameraSuccess || externalCameraSuccess) {
                startButton.disabled = false;
            } else {
                startButton.disabled = true;
            }
            updateButtonStates();
        }

        // Função para iniciar a gravação de AMBAS as câmeras (simulação)
        async function startSimultaneousRecording() {
            if (isRecording) {
                showMessageBox('A gravação já está em andamento.', 'info');
                return;
            }

            let recordingStarted = false;

            internalVideoBlob = null;
            externalVideoBlob = null;
            recordedChunksInternal = [];
            recordedChunksExternal = [];

            const preferredMimeType = 'video/webm; codecs=vp9';
            const fallbackMimeType = 'video/webm';
            let internalMimeType = '';
            let externalMimeType = '';

            // --- Gravação da Câmera Interna ---
            if (internalCameraStream) {
                try {
                    if (MediaRecorder.isTypeSupported(preferredMimeType)) {
                        internalMimeType = preferredMimeType;
                    } else if (MediaRecorder.isTypeSupported(fallbackMimeType)) {
                        internalMimeType = fallbackMimeType;
                    } else {
                        showMessageBox('Nenhum formato de vídeo suportado para gravação da câmera interna.', 'error');
                        console.error('Nenhum formato de vídeo suportado para gravação da câmera interna.');
                    }

                    if (internalMimeType) {
                        mediaRecorderInternal = new MediaRecorder(internalCameraStream, { mimeType: internalMimeType });
                        console.log(`MediaRecorder Interno criado com MIME type: ${internalMimeType}`);

                        mediaRecorderInternal.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                recordedChunksInternal.push(event.data);
                                console.log(`Dados de vídeo internos disponíveis. Tamanho: ${event.data.size}`);
                            }
                        };
                        mediaRecorderInternal.onstop = async () => {
                            internalVideoBlob = new Blob(recordedChunksInternal, { type: internalMimeType });
                            console.log('Gravação interna finalizada. Blob:', internalVideoBlob);
                            if (internalVideoBlob.size > 0) {
                                const dateTime = formatDateTimeForFilename();
                                await addVideoToIndexedDB({
                                    id: `${currentUserId || 'anonymous'}_${Date.now()}_internal`,
                                    name: `video_interno_${dateTime}.webm`,
                                    date: new Date().toLocaleString(),
                                    timestamp: Date.now(),
                                    type: 'internal',
                                    blob: internalVideoBlob
                                });
                            }
                        };
                        mediaRecorderInternal.onerror = (event) => {
                            console.error('Erro no MediaRecorder interno:', event.error);
                            showMessageBox(`Erro na gravação da câmera interna: ${event.error.message}`, 'error');
                        };
                        
                        mediaRecorderInternal.start(1000); 
                        showMessageBox('Gravação da câmera interna iniciada.', 'success');
                        recordingStarted = true;
                    }
                } catch (e) {
                    console.error('Erro ao iniciar gravação interna (MediaRecorder):', e);
                    showMessageBox(`Erro ao iniciar gravação da câmera interna: ${e.message}.`, 'error');
                }
            } else {
                showMessageBox('Câmera interna não ativa para gravação. Verifique as permissões.', 'info');
            }

            // --- Gravação da Câmera Externa ---
            if (externalCameraStream) {
                try {
                    if (MediaRecorder.isTypeSupported(preferredMimeType)) {
                        externalMimeType = preferredMimeType;
                    } else if (MediaRecorder.isTypeSupported(fallbackMimeType)) {
                        externalMimeType = fallbackMimeType;
                    } else {
                        showMessageBox('Nenhum formato de vídeo suportado para gravação da câmera externa.', 'error');
                        console.error('Nenhum formato de vídeo suportado para gravação da câmera externa.');
                    }

                    if (externalMimeType) {
                        mediaRecorderExternal = new MediaRecorder(externalCameraStream, { mimeType: externalMimeType });
                        console.log(`MediaRecorder Externo criado com MIME type: ${externalMimeType}`);

                        mediaRecorderExternal.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                recordedChunksExternal.push(event.data);
                                console.log(`Dados de vídeo externos disponíveis. Tamanho: ${event.data.size}`);
                            }
                        };
                        mediaRecorderExternal.onstop = async () => {
                            externalVideoBlob = new Blob(recordedChunksExternal, { type: externalMimeType });
                            console.log('Gravação externa finalizada. Blob:', externalVideoBlob);
                            if (externalVideoBlob.size > 0) {
                                const dateTime = formatDateTimeForFilename();
                                await addVideoToIndexedDB({
                                    id: `${currentUserId || 'anonymous'}_${Date.now()}_external`,
                                    name: `video_externo_${dateTime}.webm`,
                                    date: new Date().toLocaleString(),
                                    timestamp: Date.now(),
                                    type: 'external',
                                    blob: externalVideoBlob
                                });
                            }
                        };
                        mediaRecorderExternal.onerror = (event) => {
                            console.error('Erro no MediaRecorder externo:', event.error);
                            showMessageBox(`Erro na gravação da câmera externa: ${event.error.message}`, 'error');
                        };

                        mediaRecorderExternal.start(1000); 
                        showMessageBox('Gravação da câmera externa iniciada.', 'success');
                        recordingStarted = true;
                    }
                } catch (e) {
                    console.error('Erro ao iniciar gravação externa (MediaRecorder):', e);
                    showMessageBox(`Erro ao iniciar gravação da câmera externa: ${e.message}.`, 'error');
                }
            } else {
                showMessageBox('Câmera externa não ativa para gravação. Verifique as permissões.', 'info');
            }

            if (recordingStarted) {
                isRecording = true;
                startTimerAndShowOverlays();
                updateButtonStates();
                showMessageBox('Gravação de segurança iniciada.', 'success');
            } else {
                showMessageBox('Nenhuma câmera disponível para iniciar a gravação ou formato de vídeo não suportado.', 'error');
            }
        }

        // Função para parar a gravação (sem exibir modal de salvamento)
        function stopRecording() {
            if (!isRecording) {
                showMessageBox('Nenhuma gravação em andamento para parar.', 'info');
                return;
            }

            stopSimultaneousRecording(); // Usa a função centralizada
            showMessageBox('Gravação de segurança parada. Os vídeos foram salvos no navegador.', 'info');
            
            internalVideoBlob = null;
            externalVideoBlob = null;
            displaySavedVideos(); 
        }

        // Função para exibir a lista de vídeos salvos
        async function displaySavedVideos() {
            savedVideosList.innerHTML = ''; 
            const allVideos = await getVideosFromIndexedDB();
            const now = Date.now();
            let hasNonExpiredVideos = false;

            for (const video of allVideos) {
                const expirationTime = video.timestamp + EXPIRATION_TIME_MS;
                const timeLeft = expirationTime - now;

                if (timeLeft <= 0) {
                    await deleteVideoFromIndexedDB(video.id);
                    showMessageBox(`Vídeo "${video.name}" expirou e foi removido.`, 'info');
                    continue; 
                }

                hasNonExpiredVideos = true;
                const videoItem = document.createElement('div');
                videoItem.classList.add('saved-video-item');
                videoItem.dataset.videoId = video.id; 
                
                videoItem.onclick = () => playVideo(video.id);

                let timeLeftString;
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

                if (hours > 0) {
                    timeLeftString = `Expira em: ${hours}h ${String(minutes).padStart(2, '0')}m`;
                } else if (minutes > 0) {
                    timeLeftString = `Expira em: ${minutes}m ${String(seconds).padStart(2, '0')}s`;
                } else {
                    timeLeftString = `Expira em: ${seconds}s`;
                }

                videoItem.innerHTML = `
                    <p class="video-name-list">${video.name}</p>
                    <p class="video-date-list">Gravado em: ${video.date}</p>
                    <p class="video-expiration-info">Expira em: ${timeLeftString}</p>
                `;
                savedVideosList.appendChild(videoItem);
            }

            if (!hasNonExpiredVideos) { 
                noVideosMessage.classList.remove('hidden');
                savedVideosList.appendChild(noVideosMessage);
            } else {
                 noVideosMessage.classList.add('hidden');
            }

            if (hasNonExpiredVideos && !expirationCheckInterval) {
                expirationCheckInterval = setInterval(() => {
                    displaySavedVideos(); 
                }, 30000); 
            } else if (!hasNonExpiredVideos && expirationCheckInterval) {
                clearInterval(expirationCheckInterval);
                expirationCheckInterval = null;
            }
        }

        // Função para reproduzir um vídeo específico pelo ID do IndexedDB
        async function playVideo(videoId) {
            const videoData = await getVideoById(videoId);
            if (videoData && videoData.blob) {
                currentlyPlayingVideoId = videoId; 
                const videoUrl = URL.createObjectURL(videoData.blob);
                currentVideoPlayer.src = videoUrl;
                currentVideoPlayer.load(); 
                currentVideoPlayer.play(); 

                currentVideoNameDisplay.textContent = videoData.name;
                currentVideoDateDisplay.textContent = `Gravado em: ${videoData.date}`;
                
                const expirationTime = videoData.timestamp + EXPIRATION_TIME_MS;
                const now = Date.now();
                const timeLeft = expirationTime - now;

                if (timeLeft <= 0) {
                    currentVideoExpiration.textContent = 'Este vídeo expirou.';
                    currentVideoExpiration.classList.add('expired');
                    downloadCurrentVideoButton.disabled = true; 
                } else {
                    const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                    const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                    currentVideoExpiration.textContent = `Expira em: ${hours}h ${String(minutes).padStart(2, '0')}m`; // Formato HHh MMm
                    currentVideoExpiration.classList.remove('expired');
                    downloadCurrentVideoButton.disabled = false;
                }

                currentVideoPlayer.oncanplay = () => {
                    URL.revokeObjectURL(videoUrl); 
                };

                downloadCurrentVideoButton.onclick = () => {
                    const urlToDownload = URL.createObjectURL(videoData.blob); 
                    const a = document.createElement('a');
                    a.href = urlToDownload;
                    a.download = videoData.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(urlToDownload); 
                    showMessageBox(`Baixando: ${videoData.name}`, 'info');
                };

                deleteCurrentVideoButton.onclick = () => {
                    if (confirm(`Tem certeza que deseja excluir o vídeo "${videoData.name}"?`)) {
                        currentVideoPlayer.pause(); 
                        currentVideoPlayer.removeAttribute('src'); 
                        deleteVideoFromIndexedDB(currentlyPlayingVideoId); 
                        currentlyPlayingVideoId = null; 
                    }
                };

                showScreen('videoPlayer');
            } else {
                showMessageBox('Vídeo não encontrado ou Blob corrompido.', 'error');
            }
        }

        // Função para cancelar o salvamento (este modal foi removido do HTML)
        function cancelSave() {
            showMessageBox('Salvamento cancelado. Os vídeos não foram salvos.', 'info');
            internalVideoBlob = null;
            externalVideoBlob = null;
        }


        // --- Declaração de Elementos da UI (movida para depois das funções que os usam) ---
        const internalCameraFeed = document.getElementById('internalCameraFeed');
        const externalCameraFeed = document.getElementById('externalCameraFeed');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const panicButton = document.getElementById('panicButton');
        const messageBox = document.getElementById('messageBox');
        const internalRecordingOverlay = document.getElementById('internalRecordingOverlay');
        const internalRecordingTimer = document.getElementById('internalRecordingTimer');
        const externalRecordingOverlay = document.getElementById('externalRecordingOverlay');
        const externalRecordingTimer = document.getElementById('externalRecordingTimer');

        const loginScreen = document.getElementById('loginScreen');
        const appScreen = document.getElementById('appScreen');
        const googleSignInButton = document.getElementById('googleSignInButton');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const userIdValue = document.getElementById('userIdValue');

        const topRightLogoutButton = document.getElementById('topRightLogoutButton');

        // Referências ao modal de salvamento não são mais necessárias aqui, pois o modal foi removido do HTML
        // const saveModalOverlay = document.getElementById('saveModalOverlay');
        // const saveToPhoneButton = document.getElementById('saveToPhoneButton');
        // const cancelSaveButton = document.getElementById('cancelSaveButton');

        const savedVideosScreen = document.getElementById('savedVideosScreen');
        const savedVideosList = document.getElementById('savedVideosList');
        const viewSavedVideosButton = document.getElementById('viewSavedVideosButton');
        const backToAppButton = document.getElementById('backToAppButton');
        const noVideosMessage = document.getElementById('noVideosMessage');

        const videoPlayerScreen = document.getElementById('videoPlayerScreen');
        const currentVideoPlayer = document.getElementById('currentVideoPlayer');
        const currentVideoNameDisplay = document.getElementById('currentVideoName');
        const currentVideoDateDisplay = document.getElementById('currentVideoDate');
        const currentVideoExpiration = document.getElementById('currentVideoExpiration');
        const downloadCurrentVideoButton = document.getElementById('downloadCurrentVideoButton');
        const deleteCurrentVideoButton = document.getElementById('deleteCurrentVideoButton');
        const backToSavedVideosListButton = document.getElementById('backToSavedVideosListButton');


        // --- Event Listeners para Botões de Controle ---
        startButton.addEventListener('click', startSimultaneousRecording);
        stopButton.addEventListener('click', stopRecording); 
        panicButton.addEventListener('click', () => {
            if (isRecording) {
                stopSimultaneousRecording(); 
            }
            showMessageBox('ALERTA DE PÂNICO ATIVADO! Gravação interrompida (simulação de envio de alerta).', 'danger');
            internalVideoBlob = null;
            externalVideoBlob = null;
        });

        // Event listeners para navegação
        viewSavedVideosButton.addEventListener('click', () => {
            showScreen('savedVideos');
            displaySavedVideos(); 
        });
        backToAppButton.addEventListener('click', () => {
            showScreen('app');
        });

        // Event Listener para o botão de voltar na tela do player
        backToSavedVideosListButton.addEventListener('click', () => {
            currentVideoPlayer.pause();
            currentVideoPlayer.removeAttribute('src');
            currentlyPlayingVideoId = null;
            showScreen('savedVideos');
            displaySavedVideos(); 
        });

        // --- Funções de Login e Logout do Firebase ---

        // Função para mostrar a tela correta (login, app, savedVideos ou videoPlayer)
        function showScreen(screenId) {
            loginScreen.style.display = 'none';
            appScreen.style.display = 'none';
            savedVideosScreen.style.display = 'none';
            videoPlayerScreen.style.display = 'none'; 
            topRightLogoutButton.classList.add('hidden');

            if (screenId !== 'app') {
                stopSimultaneousRecording();
                stopCameraStreams();
            }

            switch (screenId) {
                case 'login':
                    loginScreen.style.display = 'flex';
                    if (expirationCheckInterval) {
                        clearInterval(expirationCheckInterval);
                        expirationCheckInterval = null;
                    }
                    break;
                case 'app':
                    appScreen.style.display = 'flex';
                    topRightLogoutButton.classList.remove('hidden');
                    startCameraStreams();
                    break;
                case 'savedVideos':
                    savedVideosScreen.style.display = 'flex';
                    topRightLogoutButton.classList.remove('hidden'); 
                    break;
                case 'videoPlayer':
                    videoPlayerScreen.style.display = 'flex';
                    topRightLogoutButton.classList.remove('hidden'); 
                    break;
            }
        }

        // Event listener para o botão de login do Google
        googleSignInButton.addEventListener('click', async () => {
            const provider = new GoogleAuthProvider();
            try {
                const result = await signInWithPopup(auth, provider);
                const user = result.user;
                console.log("Usuário logado:", user);
            } catch (error) {
                console.error("Erro no login com Google:", error);
                let errorMessage = "Erro desconhecido ao tentar login com Google.";
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Login cancelado. O pop-up de login foi fechado.";
                } else if (error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Login cancelado. Já havia uma solicitação de pop-up.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "O login com Google não está ativado. Ative-o nas configurações de autenticação do Firebase.";
                } else if (error.code === 'auth/auth-domain-config-error') {
                    errorMessage = "Erro de configuração de domínio de autenticação. Verifique os domínios autorizados no Firebase.";
                }
                showMessageBox(`Erro de login: ${errorMessage}`, 'error');
            }
        });

        // Event listener para o botão de logout fixo
        topRightLogoutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
                console.log("Usuário deslogado.");
            } catch (error) {
                console.error("Erro ao deslogar:", error);
                showMessageBox(`Erro ao deslogar: ${error.message}`, 'error');
            }
        });

        // --- Gerenciamento de Estado de Autenticação com Firebase ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUserId = user.uid;
                currentUserEmail = user.email;
                userIdValue.textContent = currentUserId;
                showScreen('app');
                showMessageBox(`Bem-vindo(a), ${user.displayName || 'Usuário'}!`, 'success');
            } else {
                currentUserId = null;
                currentUserEmail = null;
                userIdValue.textContent = "N/A";
                showScreen('login');
            }
            updateButtonStates();
        });

        // --- Registro do Service Worker para PWA ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrado com sucesso:', registration);
                    })
                    .catch(error => {
                        console.error('Falha no registro do Service Worker:', error);
                        showMessageBox('Erro ao registrar Service Worker. Funcionalidades offline podem não estar disponíveis.', 'error');
                    });
            });
        }
    </script>
</body>
</html>
